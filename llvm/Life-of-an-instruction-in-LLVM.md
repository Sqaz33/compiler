Оригинал: https://eli.thegreenplace.net/2012/11/24/life-of-an-instruction-in-llvm

Ниже перевод

### Жизнь инструкции в LLVM

**24 ноября 2012, 15:37**
**Теги:** Code generation, Compilation, LLVM & Clang

LLVM — это сложный программный комплекс. Существует несколько путей для понимания его работы, и ни один из них не является простым. Недавно мне пришлось углубиться в некоторые аспекты LLVM, с которыми я раньше не сталкивался, и эта статья — один из результатов этого исследования.

Цель статьи — проследить, какие превращения претерпевает "инструкция" при прохождении через различные этапы компиляции в LLVM: начиная от синтаксической конструкции в исходном языке и заканчивая её кодированием в виде машинного кода в выходном объектном файле.

Эта статья не научит вас тому, как работает LLVM. Она предполагает некоторое знакомство с архитектурой и кодом LLVM и опускает многие "очевидные" детали. Если не указано иное, информация актуальна для LLVM 3.2. LLVM и Clang — быстро развивающиеся проекты, и будущие изменения могут сделать часть этой статьи неактуальной. Если вы заметите неточности, пожалуйста, сообщите мне, и я постараюсь их исправить.

### Исходный код

Начнём с самого начала — исходного кода на C. Вот простая функция, с которой мы будем работать:

```c
int foo(int aa, int bb, int cc) {
  int sum = aa + bb;
  return sum / cc;
}
```

В центре внимания будет операция деления.

### Clang

Clang выступает в роли фронтенда для LLVM, отвечая за преобразование исходного кода на C, C++ и ObjC в LLVM IR. Основная сложность Clang связана с корректным разбором и семантическим анализом C++, но для простой операции на уровне C процесс довольно прямолинеен.

Парсер Clang строит абстрактное синтаксическое дерево (AST) из входного кода. AST — это основная "валюта", с которой работают различные части Clang. Для нашей операции деления создаётся узел `BinaryOperator` с "видом операции" `BO_div` [1]. Затем генератор кода Clang создаёт инструкцию LLVM IR `sdiv` из этого узла, так как это деление знаковых целых чисел.

### LLVM IR

Вот LLVM IR, сгенерированный для этой функции [2]:

```llvm
define i32 @foo(i32 %aa, i32 %bb, i32 %cc) nounwind {
entry:
  %add = add nsw i32 %aa, %bb
  %div = sdiv i32 %add, %cc
  ret i32 %div
}
```

В LLVM IR `sdiv` — это `BinaryOperator`, который является подклассом `Instruction` с кодом операции `SDiv` [3]. Как и любая другая инструкция, она может обрабатываться анализаторами и трансформациями LLVM. Например, см. `SimplifySDivInst`. Поскольку на протяжении всего "среднего уровня" LLVM инструкция остаётся в форме IR, я не буду подробно останавливаться на этом. Чтобы увидеть её следующее превращение, нам нужно обратиться к генератору кода LLVM.

Генератор кода — одна из самых сложных частей LLVM. Его задача — "понизить" относительно высокоуровневый, независимый от платформы LLVM IR до низкоуровневых, платформозависимых "машинных инструкций" (`MachineInstr`). На пути к `MachineInstr` инструкция LLVM IR проходит через стадию "узла SelectionDAG", о которой я расскажу далее.

### Узель SelectionDAG

Узлы SelectionDAG [4] создаются классом `SelectionDAGBuilder`, который работает "на службе" у `SelectionDAGISel` — основного базового класса для выбора инструкций. `SelectionDAGISel` проходит по всем инструкциям IR и вызывает диспетчер `SelectionDAGBuilder::visit` для них. Метод, обрабатывающий инструкцию `SDiv`, — `SelectionDAGBuilder::visitSDiv`. Он запрашивает новый `SDNode` из DAG с кодом операции `ISD::SDIV`, который становится узлом в DAG.

Первоначально построенный DAG всё ещё частично независим от платформы. В терминологии LLVM он называется "нелегальным" — типы, которые он содержит, могут не поддерживаться напрямую целевой платформой; то же самое относится и к операциям.

Есть несколько способов визуализировать DAG. Один — передать флаг `-debug` в `llc`, что приведёт к текстовому дампу DAG на всех этапах выбора. Другой — использовать один из флагов `-view`, чтобы создать и отобразить изображение графа (подробнее в документации генератора кода). Вот соответствующая часть DAG с нашим узлом `SDiv` сразу после создания (узел `sdiv` внизу):

![](https://eli.thegreenplace.net/images/2012/11/sdiv_initial_dag.png)

Перед тем как механизм SelectionDAG начнёт генерировать машинные инструкции из узлов DAG, они проходят несколько преобразований. Наиболее важные — это этапы легализации типов и операций, которые используют платформозависимые хуки для преобразования всех операций и типов в те, что поддерживаются целевой платформой.

### "Легализация" `sdiv` в `sdivrem` на x86

Инструкция деления x86 (`idiv` для знаковых операндов) вычисляет одновременно частное и остаток от деления, сохраняя их в двух разных регистрах. Поскольку выбор инструкций в LLVM различает такие операции (называемые `ISD::SDIVREM`) и деление, вычисляющее только частное (`ISD::SDIV`), наш узель DAG будет "легализован" на этапе легализации DAG для платформы x86. Вот как это происходит.

Важный интерфейс, используемый генератором кода для передачи платформозависимой информации в основном независимым от платформы алгоритмам, — это `TargetLowering`. Платформы реализуют этот интерфейс, чтобы описать, как инструкции LLVM IR должны быть понижены до легальных операций SelectionDAG. Реализация для x86 — `X86TargetLowering` [5]. В его конструкторе отмечается, какие операции должны быть "расширены" при легализации, и `ISD::SDIV` — одна из них. Вот интересный комментарий из кода:

> Скалярное целочисленное деление и остаток понижаются до операций, которые производят два результата, чтобы соответствовать доступным инструкциям. Это открывает форму с двумя результатами для тривиального CSE, который может объединить `x/y` и `x%y` в одну инструкцию.

Когда `SelectionDAGLegalize::LegalizeOp` видит флаг `Expand` у узла `SDIV` [6], он заменяет его на `ISD::SDIVREM`. Это интересный пример преобразования, которое операция может претерпеть в форме SelectionDAG.

### Выбор инструкций: от `SDNode` к `MachineSDNode`

Следующий шаг в процессе генерации кода [7] — выбор инструкций. LLVM предоставляет общий механизм выбора инструкций на основе таблиц, автоматически генерируемых с помощью TableGen. Однако многие бэкенды предпочитают писать собственный код в `SelectionDAGISel::Select` для ручной обработки некоторых инструкций. Остальные инструкции отправляются в автоматический селектор вызовом `SelectCode`.

Бэкенд x86 обрабатывает `ISD::SDIVREM` вручную, чтобы учесть специальные случаи и оптимизации. Узель DAG, созданный на этом этапе, — это `MachineSDNode`, подкласс `SDNode`, который хранит информацию, необходимую для построения фактической машинной инструкции, но всё ещё в форме узла DAG. На этом этапе выбирается фактический код операции x86 — в нашем случае `X86::IDIV32r`.

### Планирование и генерация `MachineInstr`

На этом этапе код всё ещё представлен в виде DAG. Но процессоры выполняют не DAG, а линейную последовательность инструкций. Цель этапа планирования — линеаризовать DAG, назначив порядок операциям (узлам). Простейший подход — просто отсортировать DAG топологически, но генератор кода LLVM использует умные эвристики (например, уменьшение регистрового давления), чтобы попытаться создать расписание, которое приведёт к более быстрому коду.

Каждая платформа может реализовать хуки, влияющие на планирование. Однако я не буду углубляться в эту тему.

Наконец, планировщик генерирует список инструкций в `MachineBasicBlock`, используя `InstrEmitter::EmitMachineNode` для преобразования из `SDNode`. Инструкции здесь принимают форму `MachineInstr` ("форма MI"), и DAG может быть уничтожен.

Мы можем изучить машинные инструкции, сгенерированные на этом этапе, вызвав `llc` с флагом `-print-machineinstrs` и посмотрев на первый вывод с пометкой "After instruction selection":

```asm
# After Instruction Selection:
# Machine code for function foo: SSA
Function Live Ins: %EDI in %vreg0, %ESI in %vreg1, %EDX in %vreg2
Function Live Outs: %EAX
BB#0: derived from LLVM BB %entry
    Live Ins: %EDI %ESI %EDX
        %vreg2<def> = COPY %EDX; GR32:%vreg2
        %vreg1<def> = COPY %ESI; GR32:%vreg1
        %vreg0<def> = COPY %EDI; GR32:%vreg0
        %vreg3<def,tied1> = ADD32rr %vreg0<tied0>, %vreg1, %EFLAGS<imp-def,dead>; GR32:%vreg3,%vreg0,%vreg1
        %EAX<def> = COPY %vreg3; GR32:%vreg3
        CDQ %EAX<imp-def>, %EDX<imp-def>, %EAX<imp-use>
        IDIV32r %vreg2, %EAX<imp-def>, %EDX<imp-def,dead>, %EFLAGS<imp-def,dead>, %EAX<imp-use>, %EDX<imp-use>; GR32:%vreg2
        %vreg4<def> = COPY %EAX; GR32:%vreg4
        %EAX<def> = COPY %vreg4; GR32:%vreg4
        RET
# End machine code for function foo.
```

Обратите внимание, что вывод указывает, что код находится в SSA-форме, и мы видим, что некоторые используемые регистры — "виртуальные" (например, `%vreg1`).

### Распределение регистров: от SSA к не-SSA машинным инструкциям

За исключением некоторых чётко определённых случаев, код, сгенерированный селектором инструкций, находится в SSA-форме. В частности, он предполагает, что у него есть бесконечный набор "виртуальных" регистров для работы. Это, конечно, не так. Поэтому следующий шаг генератора кода — вызов "распределителя регистров", задача которого — заменить виртуальные регистры физическими из набора целевой платформы.

Упомянутые исключения также важны и интересны, поэтому давайте обсудим их подробнее.

Некоторые инструкции на некоторых платформах требуют фиксированных регистров. Хороший пример — наша инструкция деления в x86, которая требует, чтобы её входные данные находились в регистрах `EDX` и `EAX`. Селектор инструкций знает об этих ограничениях, поэтому, как мы видим в коде выше, входы для `IDIV32r` — это физические, а не виртуальные регистры. Это назначение выполняется в `X86DAGToDAGISel::Select`.

Распределитель регистров заботится обо всех нефиксированных регистрах. Есть ещё несколько этапов оптимизации (и расширения псевдоинструкций), которые выполняются над машинными инструкциями в SSA-форме, но я их пропущу. Аналогично, я не буду обсуждать этапы, выполняемые после распределения регистров, так как они не меняют базовую форму операций (`MachineInstr` на этом этапе). Если вам интересно, посмотрите `TargetPassConfig::addMachinePasses`.

### Генерация кода

Теперь у нас есть исходная C-функция, преобразованная в форму MI — `MachineFunction`, заполненная объектами инструкций (`MachineInstr`). На этом этапе генератор кода завершает свою работу, и мы можем генерировать код. В текущей LLVM есть два способа сделать это. Первый — (устаревший) JIT, который генерирует исполняемый код напрямую в память. Второй — MC, амбициозный фреймворк для работы с объектными файлами и ассемблером, который стал частью LLVM пару лет назад, заменив предыдущий генератор ассемблера. MC сейчас используется для генерации ассемблера и объектных файлов для всех (или, по крайней мере, важных) целей LLVM. MC также включает "MCJIT" — фреймворк для JIT-компиляции на основе MC. Поэтому я называю JIT-модуль LLVM устаревшим.

Сначала я кратко расскажу о legacy JIT, а затем перейду к MC, который представляет больший интерес.

### Legacy JIT

Последовательность проходов для генерации JIT-кода определяется в `LLVMTargetMachine::addPassesToEmitMachineCode`. Она вызывает `addPassesToGenerateCode`, который определяет все проходы, необходимые для преобразования IR в форму MI (о чём и шла речь в статье). Затем вызывается `addCodeEmitter` — платформозависимый проход для преобразования MI в реальный машинный код. Поскольку MI уже очень низкоуровневый, его перевод в исполняемый машинный код довольно прямолинеен [8]. Код для x86 находится в `lib/Target/X86/X86CodeEmitter.cpp`. Для нашей инструкции деления здесь нет специальной обработки, так как `MachineInstr` уже содержит её код операции и операнды. Она обрабатывается вместе с другими инструкциями в `emitInstruction`.

### MCInst

Когда LLVM используется как статический компилятор (например, в составе clang), MI передаются на уровень MC, который отвечает за генерацию объектных файлов (он также может генерировать текстовые ассемблерные файлы). О MC можно многое рассказать, но это тема для отдельной статьи. Хороший материал — [этот пост](https://blog.llvm.org/2010/04/intro-to-llvm-mc-project.html) из блога LLVM. Я продолжу следить за судьбой одной инструкции.

`LLVMTargetMachine::addPassesToEmitFile` отвечает за определение последовательности действий для генерации объектного файла. Фактическое преобразование MI в `MCInst` выполняется в `EmitInstruction` интерфейса `AsmPrinter`. Для x86 этот метод реализован в `X86AsmPrinter::EmitInstruction`, который делегирует работу классу `X86MCInstLower`. Как и в случае с JIT, здесь нет специальной обработки для инструкции деления, и она обрабатывается вместе с другими инструкциями.

Передав `-show-mc-inst` в `llc`, мы можем увидеть инструкции уровня MC, которые он создаёт, вместе с ассемблерным кодом:

```asm
foo:                                    # @foo
# BB#0:                                 # %entry
        movl    %edx, %ecx              # <MCInst #1483 MOV32rr
                                        #  <MCOperand Reg:46>
                                        #  <MCOperand Reg:48>>
        leal    (%rdi,%rsi), %eax       # <MCInst #1096 LEA64_32r
                                        #  <MCOperand Reg:43>
                                        #  <MCOperand Reg:110>
                                        #  <MCOperand Imm:1>
                                        #  <MCOperand Reg:114>
                                        #  <MCOperand Imm:0>
                                        #  <MCOperand Reg:0>>
        cltd                            # <MCInst #352 CDQ>
        idivl   %ecx                    # <MCInst #841 IDIV32r
                                        #  <MCOperand Reg:46>>
        ret                             # <MCInst #2227 RET>
.Ltmp0:
        .size   foo, .Ltmp0-foo
```

Генерация объектного файла (или ассемблерного кода) выполняется через интерфейс `MCStreamer`. Объектные файлы генерируются `MCObjectStreamer`, который далее подклассифицируется в зависимости от формата объектного файла. Например, генерация ELF реализована в `MCELFStreamer`. Приблизительный путь `MCInst` через стримеры: `MCObjectStreamer::EmitInstruction` с последующим формато-специфичным `EmitInstToData`. Финальная генерация инструкции в бинарном виде, конечно, зависит от платформы. Этим занимается интерфейс `MCCodeEmitter` (например, `X86MCCodeEmitter`). Если в остальном коде LLVM сложность часто связана с разделением независимых и зависимых от платформы возможностей, то в MC добавляется ещё одно измерение — разные форматы объектных файлов. Поэтому часть кода полностью универсальна, часть зависит от формата, а часть — от платформы.

### Ассемблеры и дизассемблеры

`MCInst` намеренно представлен очень просто. Он старается избавиться от как можно большей семантической информации, сохраняя только код операции и список операндов (и местоположение в исходном коде для диагностики ассемблера). Как и LLVM IR, это внутреннее представление с несколькими возможными кодировками. Две самые очевидные — ассемблер (как показано выше) и бинарные объектные файлы.

`llvm-mc` — это инструмент, использующий фреймворк MC для реализации ассемблеров и дизассемблеров. Внутри `MCInst` — это представление, используемое для преобразования между бинарной и текстовой формами. На этом этапе инструменту уже не важно, какой компилятор создал ассемблерный / объектный файл.

---

### Примечания

[1] Чтобы изучить AST, создаваемое Clang, скомпилируйте исходный файл с флагами `-cc1 -ast-dump`.
[2] Я пропустил этот IR через `opt -mem2reg | llvm-dis`, чтобы очистить spills.
[3] Эти вещи сложно искать через grep из-за макросов в коде LLVM. Посмотрите `include/llvm/Instruction.def` и его использование в коде LLVM.
[4] DAG здесь означает Directed Acyclic Graph — структуру данных, которую генератор кода LLVM использует для представления операций и их зависимостей.
[5] Возможно, самый страшный кусок кода в LLVM.
[6] Пример того, как платформозависимая информация абстрагируется для управления независимыми от платформы алгоритмами.
[7] Генератор кода выполняет оптимизации DAG между основными этапами, например между легализацией и выбором инструкций.
[8] Под "машинным кодом" здесь подразумеваются байты в буфере, представляющие инструкции для CPU. JIT направляет CPU на выполнение этого буфера после генерации.

*(Перевод завершён с сохранением терминов и названий модулей/классов.)*
